#+TITLE: General Problem Solver in Common Lisp
#+HTML_HEAD: <style type="text/css">
#+HTML_HEAD: .org-svg {width : 800px}
#+HTML_HEAD: </style>
* PREFACE
**The computer code here is not original to me.** and this document reflects several of my ongoing projects:
1. Learning 'classic' AI by working through Peter Norvig's [[http://norvig.com/paip.html][*Paradigms of Artificial Intelligence: Case Studies in Common Lisp*]].   Norvig's book is the source for the Lisp code in this project.
2. Learning more Emacs in general and org-mode in particular.
3. Developing a work process around Literate Programming.
* INTRODUCTION
The General Problem Solver was developed in 1957 by [[https://en.wikipedia.org/wiki/Allen_Newell][Alan Newell]], [[https://en.wikipedia.org/wiki/Cliff_Shaw][Cliff Shaw]] and [[https://en.wikipedia.org/wiki/Herbert_A._Simon][Herbert Simon]]. The paper associated with their initial work is [[http://bitsavers.informatik.uni-stuttgart.de/pdf/rand/ipl/P-1584_Report_On_A_General_Problem-Solving_Program_Feb59.pdf][*A Report on a General Problem Solving Program*]]. However, the code in this version is based on Chapter 4 of [[http://norvig.com/paip.html][*Paradigms of Artificial Intelligence: Case Studies in Common Lisp*]].

Outside of historical value, the General Problem Solver is deemed a failure due to the likelihood of combinatorial explosion. But as I work through the code base, I can't help but appreciate the soundness of its program structure and logic...it was developed years before the discovery of NP-hard and it seems like an approach that at least allows for solving simple problems in a straight forward way. This is due, I think to the quality of its abstractions over state and mutating it.

** GPS Main Components
1. A vocabulary for talking about the task environment: operators, objects, difference, feature, etc.
2. A vocabulary for dealing with the organization of problem-solving processes: goal, method, evaluation.
3. Programs defining the terms of the problem solving vocabulary in terms of the task environment vocabulary.
4. A set of correlative definitions applying the task-environment vocabulary to a particular domain environment.
** Goal Types
1. Transform =object a= into =object b= by applying operators from the task environment. An example is proof from axioms.
2. Apply =operator q= to =object a= or an object obtained from a by admissible transformations. An example is integrating an expression.
3. Reduce the difference (distance) between =object a= and =object b= by transforming =object a=.
** Heuristics
The main heuristic is the principle of sub-goal reduction: reduce hard goals to sets of easier goals. This assumes that the difference between the current state and the goal can be determined; operators have partial effects on the environment and some portions always remain unchanged by each operator; some differences are harder to effect than others and so it is good practice to eliminate hard differences at the cost of introducing easier differences so long as progress is made.

** Executive Structure of GPS
Make the diagram using Graphviz's Dot language.
#+BEGIN_SRC dot :file gps-exec.svg :exports both
digraph G {
size="5,5";
ratio=1.1;
a[label="Command to\nachieve goal", shape=plaintext];
b[label="Evaluate Goal", shape=box];
bb[label="Do not try\nto achieve", shape=plaintext];
c[label="Select method\nfor this type of goal", shape=box];
d[label="Execute method", shape=box];
e[label="Goal achieved", shape=plaintext];
splines=ortho;
{
a -> b -> c -> d -> e;
}
rank=same {b, bb}
b:e -> bb:w [label="Reject"];
d:w -> b:w [xlabel="Goal\nnot\nachieved", constraint=false];
}
#+END_SRC

#+CAPTION: Executive Organization of GPS
#+RESULTS:
[[file:gps-exec.svg]]

/Source code for this diagram is written in/ =graphviz= /and contained in the literate programming file./

* PROCESS STAGES
** Description
The description of problem solving uses the theory of means-ends analysis. The problem is stated in terms of what we want to happen and look at the difference between what we want and what we have. Some actions have preconditions.
** Specification
The specification has seven parts.
+ Represent the current state of the world (environment) as a set of conditions. Represent the desired state of the world as a set of conditions.
+ A list of allowable operators.
+ Each operator is: a list of preconditions, an action, a list of effects.
+ A complete problem is a starting state, a goal state, a set of known operators.
+ A goal condition can be achieved two ways: it is in the current state or by applying an operator to the current environment.
+ An operator is appropriate if it adds the goal to the environment.
+ An operator can be applied if all the preconditions for its application can be met.
* VERSION ONE
This is the first iteration of GPS from Norvig's book. It is an exercise to get something to run, but it has problems that are discussed at the end of this section. There is a second version of GPS provided in the next section. 
** Implementation
*** Glossary
#+NAME: program_glossary
+-----------------------------------------------------------+
|                *Top Level Function*                       |
|GPS             Solve a goal from a state                  |
|                using a list of operators.                 |
+-----------------------------------------------------------+
|                *Special Variables: Current*               |
|*state*         Global State                              |
|*ops*           A List of operators                       |
+-----------------------------------------------------------+  
|                *Data Types*                               |
|op              An operation with preconditions,           |
|                an add-list and a del-list                 |
+-----------------------------------------------------------+
|                *Functions*                                |
|achieve         Achieve an individual goal.                |
|appropriate-p   Decide if an operator achieves a goal.     |
|applyop         Apply operator to the current state.       |       
+-----------------------------------------------------------+
|                *Common Lisp Functions*                    |
|member                                                     |
|setdifference                                              |
|union                                                      |
|every                                                      |
|some                                                       |
+-----------------------------------------------------------+
|                *Previously defined functions*             |
|findall         Find all occurrences of an element in list. |
+-----------------------------------------------------------+
*** GPS
 For literate programming purposes the source block name had to use 'one' instead of '1' to work with =:noweb=.
 #+NAME: gps-v-one
 #+BEGIN_SRC lisp :tangle gps-v-one.lisp :noweb tangle
   ;;; THIS FILE AUTOGENERATATED

   ;;; Helper Function
   <<find-all-v-one>>

   ;;; Special Variables
   <<special-variables-v-one>>

   ;;; Operations
   <<op-v-one>>

   ;;; Main
     (defun gps (*state* goals *ops*)
       "General Problem Solver: achieve all goals using *ops*."
       (if (every #'achieve goals) 'solved))

   ;;; Functions
   <<achieve-v-one>>

   <<appropriate-p-v-one>>

   <<apply-op-v-one>>
 #+END_SRC
*** Special Variables
 #+NAME: special-variables-v-one
 #+BEGIN_SRC lisp
   (defvar *state* nil "The current state: a list of all conditions.")
   (defvar *ops* nil "A list of available operations.")
 #+END_SRC

*** Op Data Structure
 Note that =nil= is the default value for each field of the =op= structure. 
 #+NAME: op-v-one
 #+BEGIN_SRC lisp
   (defstruct op
     "An operation."
     (action nil)
     (preconds nil)
     (add-list nil)
     (del-list nil))
 #+END_SRC
*** Achieve
 #+NAME: achieve-v-one
 #+BEGIN_SRC lisp
   (defun achieve (goal)
     "A goal is achieved if it already holds. Or if there
      is an appropriate op for it that is applicable."
     (or (member goal *state*)
         (some #'apply-op
               (find-all goal *ops* :test #'appropriate-p))))
 #+END_SRC
*** Appropriate-p
 #+NAME: appropriate-p-v-one
 #+BEGIN_SRC lisp
   (defun appropriate-p (goal op)
     "An op is appropriate to a goal if the goal is on the op's add-list."
     (member goal (op-add-list op)))
 #+END_SRC
*** Apply-op
 #+NAME: apply-op-v-one
 #+BEGIN_SRC lisp
   (defun apply-op (op)
     "Print a message and update *state* when op is applicable."
     (when (every #'achieve (op-preconds op))
       (print (list 'executing (op-action op)))
       (setf *state* (set-difference *state* (op-del-list op)))
       (setf *state* (union *state* (op-add-list op)))))
 #+END_SRC
*** find-all
 =FIND-ALL= is introduced early in the book and provides an example of a user function that has many of the features of a Common Lisp built-in function.
 #+NAME: find-all-v-one
 #+BEGIN_SRC lisp
   (defun find-all (item sequence &rest keyword-args
                                  &key (test #'eql)
                                  test-not
                                  &allow-other-keys)
     "Find all those elements of sequence that match item.
      according to the keywords. Does not alter sequence"
     (if test-not
         (apply #'remove item sequence
                :test-not (complement test-not) keyword-args)
         (apply #'remove item sequence
                :test (complement test) keyword-args)))
 #+END_SRC
** Problems
*** Running Around the Block Problem
Version One does not handle the run for the side effects case where the start state and the end state are the same...e.g. if we run around the block for exercise.
*** Clobbered Sibling Goal Problem
The code only checks if each goal requirement is achieved at some point, therefore
#+BEGIN_SRC lisp
  (gps '(son-at-home car-needs-battery have-money have-phone-book)
       '(have-money son-at-school)
       *school-ops*)

  => SOLVED
#+END_SRC
Despite repairing the car using all the money.
*** Leaping Before Looking Problem
GPS will choose a course of action and continue it regardless of whether it will solve the problem. Even worse, it will not back up and try a different approach after hitting a dead end.
*** Recursive Subgoals  Problem
It is possible to create operations which will send GPS into an infinite loop.
*** Lack of Intermediate Information
GPS will report failure but only as =NIL=. It will not report what it tried.
* VERSION TWO
At one level, adding GPSv2 into this same source file is kind of a mess. But it makes for a richer exercise from an Emacs/Org-Babel/Literate Programming perspective. It certainly pushes me to understand more about the topic and makes for a more robust documentation of the project's development.
** GPS Debugger
The first of the problems with =Version One= to be addressed is the Lack of Intermediate Information. Using a debugger seems like a reasonable approach: =using-a-debugger= requires =having-a-debugger= and =having-a-debugger= requires =writing-a-debugger=. It's what I love about this book, it's GPS all the way down.
#+NAME: debugger
#+BEGIN_SRC lisp :tangle gps-debugger.lisp
  (defvar *dbg-ids* nil
    "Identifiers used by dbg")

  (defun dbg (id format-string &rest args)
    "Print debugging information if (DEBUG-ID) has been specified."
    (when (member id *dbg-ids*)
      (fresh-line *debug-io*)
      (apply #'format *debug-io* format-string args)))

  ;;; Using gps-debug because 'debug' reserved in SBCL
  (defun gps-debug (&rest ids)
    "Start dbg output on the given ids."
    (setf *dbg-ids* (union ids *dbg-ids*)))

  (defun undebug (&rest ids)
    "Stop dbg on the ids. With no ids, stop debugging altogether."
    (setf *dbg-ids* (if (null ids) nil
                      (set-difference *dbg-ids* ids))))

  (defun dbg-indent (id indent format-string &rest args)
    "Print indented debugging info if (DEBUG ID) has been specified."
    (when (member id *dbg-ids*)
      (fresh-line *debug-io*)
      (dotimes (i indent) (princ "   " *debug-io*))
      (apply #'format *debug-io* format-string args)))
#+END_SRC
For the current project, I am just going to =load= the debugger into GPSv2 rather than setting up ASDF...because my head is not quite wrapped around ASDF yet in terms of how it would work with this project.
#+NAME: load-gps-debugger-v-two
#+BEGIN_SRC lisp
  (load "gps-debugger.lisp")
#+END_SRC
** Glossary
+-----------------------------------------------------------------------+
|                *Top Level Function*                                   |
|GPS             Solve a goal from a state using a list of operators.   |
+-----------------------------------------------------------------------+
|                *Special Variables*                                    |
|*ops*           A List of available operators.                         |
+-----------------------------------------------------------------------+
|                *Data Types*                                           |
|op              An operation with preconds, add-list, del-list.        |
+-----------------------------------------------------------------------+
|                *Major Functions*                                      |
|achieve-all     Achieve a list of goals.                               |
|achieve         Achieve a single goal.                                 |
|appropriate-p   Decide if an operator is appropriate to a goal.        |
|apply-op        Apply operator to current state.                       |
+-----------------------------------------------------------------------+
|                *Auxiliary Functions*                                  |
|executing-p     Is condition an executing form?                        |
|starts-with     Is the argument a list that starts with a given atom?  |
|convert-op      Convert an operator to use the executing convention.   |
|op              Create an operator.                                    |
|use             Use a list of operators.                               |
|member-equal    Test if an element is equal to a member of a list.     |
+-----------------------------------------------------------------------+
|                *Selected Common Lisp Functions*                       |
|member          Test if an element is a member of a list.              |
|set-difference  All elements in one set but not in the other.          |
|subsetp         Is one set wholly contained in another?                |
|union           All elements in either of two sets.                    |
|every           Test if every element of a list passes test.           |
|some            Test if any element of a list passes test.             |
|remove-if       Remove all items satisfying a test.                    |
+-----------------------------------------------------------------------+
|                *Previously Defined Functions*                         |
|find-all        A list of all matching elements.                       |
|find-all-if     A list of all elements satisfying a predicate.        |
+-----------------------------------------------------------------------+

** GPS
#+NAME: gps 
#+BEGIN_SRC lisp :noweb tangle :tangle gps.lisp
  ;; This file was auto generated from
  ;; general-problem-solver.org

  <<load-gps-debugger-v-two>>

  <<special-variables-v-two>>

  <<op-v-two>>

  <<major-functions-v-two>>

  <<auxiliary-functions-v-two>>

  <<previously-defined-functions-v-two>>
#+END_SRC
** Special Variables
GPS Version Two handles state differently than version one and so only requires the =*ops*= parameter. The =*ops*= parameter allows the creation of different applications based on the use of different operations. This ability is what puts the 'general' in GPS.
#+NAME: special-variables-v-two
#+BEGIN_SRC lisp
(defvar *ops* nil "A list of available operators.")
#+END_SRC
** Data Structure
The =op= data structure is not changed from version one so we can reuse it. But I'll still make a source code block to make changes easier in the future.
#+NAME: op-v-two
#+BEGIN_SRC lisp :noweb tangle
  <<op-v-one>>
#+END_SRC
** Major Functions
#+NAME: major-functions-v-two
#+BEGIN_SRC lisp :noweb tangle
  ;;; Major Functions

  <<achieve-all-v-two>>

  <<achieve-v-two>>

  <<appropriate-p-v-two>>

  <<apply-op-v-two>>

#+END_SRC
The only additional function for GPS Version 2 is the addition of =achieve-all=. However, the other functions: =achieve=, =appropriate-p=, and =apply-op= are modified.
*** Achieve-all
Achieve all is Norvig's solution to the clobbered sibling goal. It makes ensures that after achieving the goals, all the goals are still in the current state of the world. 
#+NAME: achieve-all-v-two
#+BEGIN_SRC lisp
  (defun achieve-all (state goals goal-stack)
    "Try to achieve each goal and make sure each still holds at the end."
    (let ((current-state state))
      (if (and (every #'(lambda (g)
                          (setf current-state
                                (achieve current-state g goal-stack)))
                      goals)
               (subsetp goals current-state :test #'equal))
          current-state)))
#+END_SRC
The new version of =achieve= is designed to handle the recursive subgoal problem. It uses a 'goal stack' to check if the current goal has become a sub-goal of itself.
#+NAME: achieve-v-two
#+BEGIN_SRC lisp
  (defun achieve (state goal goal-stack)
    "A goal is achieved if:\n  It already holds\n  Or\n There is an applicable appropriate op."
    (dbg-indent :gps (length goal-stack) "Goal: ~a" goal)
    (cond ((member-equal goal state) state)
          ((member-equal goal goal-stack) nil)
          (t (some #'(lambda (op)
                       (apply-op state goal op goal-stack))
                   (find-all goal *ops* :test appropriate-p)))))
#+END_SRC
#+NAME: appropriate-p-v-two
#+BEGIN_SRC lisp

#+END_SRC
#+NAME: apply-op-v-two
#+BEGIN_SRC lisp

#+END_SRC

*** Achieve
#+NAME: achieve-v-two
#+BEGIN_SRC lisp

#+END_SRC
*** Appropriate-p
#+NAME: appropriate-p-v-two
#+BEGIN_SRC lisp

#+END_SRC
*** Apply-op
#+NAME: apply-op-v-two
#+BEGIN_SRC lisp

#+END_SRC
** Auxiliary Functions
These functions implement a new form for ops so that the action list contains an "executing" action to address the running around the block problem. There is also a conversion function to back port the changed structure to *school-ops*.
#+NAME: auxiliary-functions-v-two
#+BEGIN_SRC lisp
  (defun executing-p (x)
    "Is the form: (executing...)?"
    (starts-with x 'executing))

  (defun starts-with (list x)
    "Is this a list whose first element is x?"
    (and (consp list)
         (eql (first list) s)))

  (defun convert-op (op)
    "Make op conform to the (EXECUTING op) convention."
    (unless (some #'executing-p (op-add-list op))
      (push (list 'executing (op-action op))
            (op-add-list op)))
    op)

  (defun op (action &key preconds add-list del-list)
    "Make a new operator that obeys the (EXECUTING op) convention."
    (make-op :action action
             :preconds preconds
             :add-list add-list
             :del-list del-list))
#+END_SRC
** Previously Defined Functions
The function =find-all= does not change from GPS Version One. Norvig uses =find-all-if= as an example of naming clarifying a potential use case earlier in the book. In hindsight the use case seems obvious, but there's kinda/sorta a double negative in =remove-if-not= standing in the way.
#+NAME: previously-defined-functions-v-two
#+BEGIN_SRC lisp :noweb tangle
  <<find-all-v-one>>
  (setf (symbol-function 'find-all-if) #'remove-if-not)
#+END_SRC
* KNOWLEDGE BASES
** Parameterize knowledge base
This is one of the techniques that Norvig introduces early in the book. The idea of parameters is that changing the parameters, creates a different program. For example, the school parameters here create a program that solves the problem of getting the son to school. A different set of parameters will create a 'different' problem solver.
** School Ops
The parameter =*school-ops*= could be shorter by leaving out the fields that are =nil= since it is the default for the =op= structure and Norvig does so in the book.  However, being explicit has the advantage of requiring less local knowledge and the advantage of creating a more regular pattern within the code similar to the design recipes in *How to Design Programs*.
#+NAME: school-ops
#+BEGIN_SRC lisp
  (defparameter *school-ops*
    (list
     (make-op
      :action 'drive-son-to-school
      :preconds '(son-at-home car-works)
      :add-list '(son-at-school)
      :del-list '(son-at-home))
     (make-op
      :action 'shop-installs-battery
      :preconds '(car-needs-battery shop-knows-problem shop-has-money)
      :add-list '(car-works)
      :del-list nil)
     (make-op
      :action 'tell-shop-problem
      :preconds '(in-communication-with-shop)
      :add-list '(shop-knows-problem)
      :del-list 'nil)
     (make-op
      :action 'telephone-shop
      :preconds '(know-phone-number)
      :add-list '(in-communication-with-shop)
      :del-list nil)
     (make-op
      :action 'look-up-number
      :preconds '(have-phone-book)
      :add-list '(know-phone-number)
      :del-list nil)
     (make-op
      :action 'give-shop-money
      :preconds '(have-money)
      :add-list '(shop-has-money)
      :del-list '(have-money))))
#+END_SRC
* TESTING CODE
** GPSv1 School Ops
A complete package of source and parameters (essentially an application) for the first version of GPS with the School Ops...gotta love literate programming.
#+BEGIN_SRC lisp :tangle gps-v-one-school-ops.lisp :noweb tangle
  ;;; THIS FILE AUTOGENERATED
  ;;;
  ;;; This file combines GPS version 1 with school ops to allow testing.
  ;;; Example use:
  ;;; (gps '(son-at-home car-needs-battery have-money have-phone-book) '(son-at-school) *school-ops*)
  ;;; (gps '(son-at-home have-money) '(son-at-school) *school-ops*)
  ;;; (gps '(son-at-school) '(son-at-school) *school-ops*)
  ;;;

  <<school-ops>>

  <<gps-v-one>>
#+END_SRC
* Appendix
** Using this file
1. The output for this file is =general-problem-solver.lisp=.
2. The web page for this file is =index.html=. It is structured to work with Github pages.
3. To generate these files, navigate into the source block and use =M-x org-babel-execute-src-block=.
#+NAME: generate-files
#+BEGIN_SRC elisp
  ;; label for search: qqhz
  ;; generate general-problem-solver.lisp
  (org-babel-tangle)
  ;; generate docs/index.html
  (org-html-export-as-html)
  (save-current-buffer
    (set-buffer "*Org HTML Export*")
    (write-file "index.html")
    (kill-buffer))
  (concat "Files Generated: " (current-time-string))
#+END_SRC

#+RESULTS: generate-files
: Files Generated: Wed Feb  8 21:03:57 2017
