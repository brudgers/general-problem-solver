#+TITLE: General Problem Solver in Common Lisp
* PREFACE
**The computer code here is not original to me.** and this document reflects several of my ongoing projects:
1. Learning 'classic' AI by working through Peter Norvig's [[http://norvig.com/paip.html][*Paradigms of Artificial Intelligence: Case Studies in Common Lisp*]].   Norvig's book is the source for the Lisp code in this project.
2. Learning more Emacs in general and org-mode in particular.
3. Developing a work process around Literate Programming.
* INTRODUCTION
The General Problem Solver was developed in 1957 by [[https://en.wikipedia.org/wiki/Allen_Newell][Alan Newell]], [[https://en.wikipedia.org/wiki/Cliff_Shaw][Cliff Shaw]] and [[https://en.wikipedia.org/wiki/Herbert_A._Simon][Herbert Simon]]. The paper associated with their initial work is [[http://bitsavers.informatik.uni-stuttgart.de/pdf/rand/ipl/P-1584_Report_On_A_General_Problem-Solving_Program_Feb59.pdf][*A Report on a General Problem Solving Program*]]. However, the code in this version is based on Chapter 4 of [[http://norvig.com/paip.html][*Paradigms of Artificial Intelligence: Case Studies in Common Lisp*]]. 

Outside of historical value, the General Problem Solver is deemed a failure due to the likelihood of combinatorial explosion. But as I work through the code base, I can't help but appreciate the soundness of its program structure and logic...it was developed years before the discovery of NP-hard and it seems like an approach that at least allows for solving simple problems in a straight forward way. This is due, I think to the quality of its abstractions over state and mutating it.

** GPS Main Components
1. A vocabulary for talking about the task environment: operators, objects, difference, feature, etc.
2. A vocabulary for dealing with the organization of problem-solving processes: goal, method, evaluation.
3. Programs defining the terms of the problem solving vocabulary in terms of the task environment vocabulary.
4. A set of correlative definitions applying the task-environment vocabulary to a particular domain environment.
** Goal Types
1. Transform =object a= into =object b= by applying operators from the task environment. An example is proof from axioms.
2. Apply =operator q= to =object a= or an object obtained from a by admissible transformations. An example is integrating an expression.
3. Reduce the difference (distance) between =object a= and =object b= by transforming =object a=.
** Heuristics
The main heuristic is the principle of sub-goal reduction: reduce hard goals to sets of easier goals. This assumes that the difference between the current state and the goal can be determined; operators have partial effects on the environment and some portions always remain unchanged by each operator; some differences are harder to effect than others and so it is good practice to eliminate hard differences at the cost of introducing easier differences so long as progress is made.

** Executive Structure of GPS

#+BEGIN_SRC dot :file gps-exec.svg :exports results
digraph G {
ratio=1.1;
a[label="Command to\nachieve goal", shape=plaintext];
b[label="Evaluate Goal", shape=box];
bb[label="Do not try\nto achieve", shape=plaintext];
c[label="Select method\nfor this type of goal", shape=box];
d[label="Execute method", shape=box];
e[label="Goal achieved", shape=plaintext];
splines=ortho;
{
a -> b -> c -> d -> e;
}
rank=same {b, bb}
b:e -> bb:w [label="Reject"];
d:w -> b:w [xlabel="Goal\nnot\nachieved", constraint=false];
}
#+END_SRC

#+CAPTION: Executive Organization of GPS
#+RESULTS:
[[file:gps-exec.svg]]

/Source code for this diagram is written in/ =graphviz= /and contained in the literate programming file./

* PROCESS STAGES
** Description
The description of problem solving uses the theory of means-ends analysis. The problem is stated in terms of what we want to happen and look at the difference between what we want and what we have. Some actions have preconditions.
** Specification
The specification has seven parts.
+ Represent the current state of the world (environment) as a set of conditions. Represent the desired state of the world as a set of conditions.
+ A list of allowable operators.
+ Each operator is: a list of preconditions, an action, a list of effects.
+ A complete problem is a starting state, a goal state, a set of known operators.
+ A goal condition can be achieved two ways: it is in the current state or by applying an operator to the current environment.
+ An operator is appropriate if it adds the goal to the environment.
+ An operator can be applied if all the preconditions for its application can be met.
** Implementation
#+NAME: program_glossary
  +---------------+----------------------------+
  |GPS            |Top Level Function: Solve a |
  |               |goal from a state using a   |
  |               |list of operators           |
  |               |                            |
  +---------------+----------------------------+
  |               |Special Variables: Current  |
  |*state*        |State and a list of         |
  |*ops*          |operators                   |
  |               |                            |
  +---------------+----------------------------+
  |               |Data Types: An operation    |
  |op             |with preconditions, add-list|
  |               |and del-list                |
  |               |                            |
  |               |                            |
  +---------------+----------------------------+
  |               |Functions: Achieve an       |
  |achieve        |individual goal, Decide if  |
  |appropriate-p |an operator achieves a goal.|
  |apply-op       |Apply operator to the       |
  |               |current state.              |
  +---------------+----------------------------+
  |member,        |Common Lisp Functions        |
  |set-difference,|                            |
  |union, every,  |                            |
  |some           |                            |
  +---------------+----------------------------+
  |find-all       |Previously defined functions|
  +---------------+----------------------------+
*** Helper Functions
#+NAME: find-all          
#+BEGIN_SRC lisp :tangle yes
  (defun find-all (item sequence &rest keyword-args
                                 &key (test #'eql)
                                 test-not
                                 &allow-other-keys)
    "Find all those elements of sequence that match item.
     according to the keywords. Does not alter sequence"
    (if test-not
        (apply #'remove item sequence
               :test-not (complement test-not) keyword-args)
        (apply #'remove item sequence
               :test (complement test) keyword-args)))
#+END_SRC
*** Special Variables
#+NAME: special-variables
#+BEGIN_SRC lisp :tangle yes
  (defvar *state* nil "The current state: a list of all conditions.")
  (defvar *ops* nil "A list of available operations.")
#+END_SRC

*** Operations
Note that =nil= is the default value for each field of the =op= structure.
#+NAME: op
#+BEGIN_SRC lisp :tangle yes
  (defstruct op
    "An operation."
    (action nil)
    (preconds nil)
    (add-list nil)
    (del-list nil))
#+END_SRC

*** GPS
#+NAME: gps
#+BEGIN_SRC lisp :tangle yes
  (defun gps (*state* goals *ops*)
    "General Problem Solver: achieve all goals using *ops*."
    (if (every #'achieve goals) 'solved))
#+END_SRC
*** Functions
#+BEGIN_SRC lisp :tangle yes
  (defun achieve (goal)
    "A goal is achieved if it already holds. Or if there
     is an appropriate op for it that is applicable."
    (or (member goal *state*)
        (some #'apply-op
              (find-all goal *ops* :test #'appropriate-p))))

  (defun appropriate-p (goal op)
    "An op is appropriate to a goal if the goal is on the op's add-list."
    (member goal (op-add-list op)))

  (defun apply-op (op)
    "Print a message and update *state* when op is applicable."
    (when (every #'achieve (op-preconds op))
      (print (list 'executing (op-action op)))
      (setf *state* (set-difference *state* (op-del-list op)))
      (setf *state* (union *state* (op-add-list op)))))
#+END_SRC
** Testing
*** Parameterize knowledge base
This is one of the techniques that Norvig introduces early in the book. The idea of parameters is that changing the parameters, creates a different program. For example, the school parameters here create a program that solves the problem of getting the son to school. A different set of parameters will create a 'different' problem solver.

The parameter =*school-ops*= could be shorter by leaving out the fields that are =nil= since it is the default for the =op= structure and Norvig does so in the book.  However, being explicit has the advantage of requiring less local knowledge and the advantage of creating a more regular pattern within the code similar to the design recipes in *How to Design Programs*.

#+BEGIN_SRC lisp :tangle yes
  (defparameter *school-ops*
    (list
     (make-op
      :action 'drive-son-to-school
      :preconds '(son-at-home car-works)
      :add-list '(son-at-school)
      :del-list '(son-at-home))
     (make-op
      :action 'shop-installs-battery
      :preconds '(car-needs-battery shop-knows-problem shop-has-money)
      :add-list '(car-works)
      :del-list nil)
     (make-op
      :action 'tell-shop-problem
      :preconds '(in-communication-with-shop)
      :add-list '(shop-knows-problem)
      :del-list 'nil)
     (make-op
      :action 'telephone-shop
      :preconds '(know-phone-number)
      :add-list '(in-communication-with-shop)
      :del-list nil)
     (make-op
      :action 'look-up-number
      :preconds '(have-phone-book)
      :add-list '(know-phone-number)
      :del-list nil)
     (make-op
      :action 'give-shop-money
      :preconds '(have-money)
      :add-list '(shop-has-money)
      :del-list '(have-money))))
#+END_SRC
* Appendix
** Using this file
1. The output for this file is =general-problem-solver.lisp=.
2. The web page for this file is =index.html=. It is structured to work with Github pages.
3. To generate these files, navigate into the source block and use =M-x org-babel-execute-src-block=. 
#+NAME: generate-files
#+BEGIN_SRC elisp
  ;; label for search: qqz
  ;; generate general-problem-solver.lisp
  (org-babel-tangle)
  ;; generate docs/index.html
  (org-html-export-as-html)
  (save-current-buffer
    (set-buffer "*Org HTML Export*")
    (write-file "index.html")
    (kill-buffer))
  (concat "Files Generated: " (current-time-string))
#+END_SRC 

#+RESULTS: generate-files
: Files Generated: Wed Feb  1 11:06:59 2017
