#+TITLE: General Problem Solver in Common Lisp
* INTRODUCTION
The General Problem Solver was developed in 1957 by Alan Newell and Herbert Simon. This version is based on Chapter 4 of *Paradigms of Artificial Intelligence: Case Studies in Common Lisp*.
** Using this file
1. The output for this file is =tictactoe.el=.
2. The web page for this file is =docs/index.html=. It is structured to work with Github pages.
3. To generate these files, navigate into the source block and use =M-x org-babel-execute-src-block=. 
#+NAME: generate-files
#+BEGIN_SRC elisp
  ;; generate general-problem-solver.lisp
  (org-babel-tangle)
  ;; generate docs/index.html
  (org-html-export-as-html)
  (save-current-buffer
    (set-buffer "*Org HTML Export*")
    (write-file "docs/index.html")
    (kill-buffer))
  (concat "Files Generated: " (current-time-string))
#+END_SRC 

#+RESULTS: generate-files
: Files Generated: Wed Jan 25 17:02:32 2017

* PROCESS STAGES
** Description
The description of problem solving uses the theory of means-ends analysis. The problem is stated in terms of what we want to happen and look at the difference between what we want and what we have. Some actions have preconditions.
** Specification
The specification has seven parts.
+ Repesent the current state of the world (environment) as a set of conditions. Represent the desired state of the world as a set of conditions.
+ A list of allowable operators.
+ Each operator is: a list of preconditions, an action, a list of effects.
+ A complete problem is a starting state, a goal state, a set of known operators.
+ A goal condition can be achieved two ways: it is in the current state or by applying an operator to the current environment.
+ An operator is appropriate if it adds the goal to the environment.
+ An operator can be applied if all the preconditions for its application can be met.
** Implementation
#+NAME: program_glossary
  +---------------+----------------------------+
  |GPS            |Top Level Function: Solve a |
  |               |goal from a state using a   |
  |               |list of operators           |
  |               |                            |
  +---------------+----------------------------+
  |               |Special Variables: Current  |
  |*state*        |State and a list of         |
  |*ops*          |operators                   |
  |               |                            |
  +---------------+----------------------------+
  |               |Data Types: An operation    |
  |op             |with preconditions, add-list|
  |               |and del-list                |
  |               |                            |
  |               |                            |
  +---------------+----------------------------+
  |               |Functions: Achieve an       |
  |achieve        |individual goal, Decide if  |
  |approprriate-p |an operator achieves a goal.|
  |apply-op       |Apply operator to the       |
  |               |current state.              |
  +---------------+----------------------------+
  |member,        |Common Lisp Funtions        |
  |set-difference,|                            |
  |union, every,  |                            |
  |some           |                            |
  +---------------+----------------------------+
  |find-all       |Previously defined functions|
  +---------------+----------------------------+
*** Helper Functions
#+NAME: find-all          
#+BEGIN_SRC lisp :tangle yes
  (defun find-all (item sequence &rest keyword-args
                                 &key (test #'eql)
                                 test-not
                                 &allow-other-keys)
    "Find all those elements of sequence that match item.
     according to tthe keywords. Does not alter sequence"
    (if test-not
        (apply #'remove item sequence
               :test-not (complement test-not) keyword-args)
        (apply #'remove item sequence
               :test (complement test) keyword-args)))
#+END_SRC
*** Special Variables
#+NAME: special-variables
#+BEGIN_SRC lisp :tangle yes
  (defvar *state* nil "The current state: a list of all conditions.")
  (defvar *ops* nil "A list of available operations.")
#+END_SRC

*** Operations
Note that =nil= is the default value for each field of the =op= structure.
#+NAME: op
#+BEGIN_SRC lisp :tangle yes
  (defstruct op
    "An operation."
    (action nil)
    (preconds nil)
    (add-list nil)
    (del-list nil))
#+END_SRC

*** GPS
#+NAME: gps
#+BEGIN_SRC lisp :tangle yes
  (defun GPS (*state* goals *ops*)
    "General Problem Solver: acieve all goals using *ops*."
    (if (every #'achieve goals) 'solved))
#+END_SRC
