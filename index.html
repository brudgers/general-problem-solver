<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-02-19 Sun 15:35 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>General Problem Solver in Common Lisp</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="benrudgers" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">General Problem Solver in Common Lisp</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8eea4e2">PREFACE</a></li>
<li><a href="#org0f11e90">INTRODUCTION</a>
<ul>
<li><a href="#orge759882">GPS Main Components</a></li>
<li><a href="#orgd98b1e1">Goal Types</a></li>
<li><a href="#org3161808">Heuristics</a></li>
<li><a href="#orgecb5503">Executive Structure of GPS</a></li>
</ul>
</li>
<li><a href="#org275c35e">PROCESS STAGES</a>
<ul>
<li><a href="#org332dc41">Description</a></li>
<li><a href="#org2ee055c">Specification</a></li>
</ul>
</li>
<li><a href="#org268e224">VERSION ONE</a>
<ul>
<li><a href="#orgf756a22">Implementation</a>
<ul>
<li><a href="#org5494d1a">Glossary</a></li>
<li><a href="#orgd220586">GPS</a></li>
<li><a href="#org11dd041">Special Variables</a></li>
<li><a href="#org90c555e">Op Data Structure</a></li>
<li><a href="#orga065ad1">Achieve</a></li>
<li><a href="#orga02ae0c">Appropriate-p</a></li>
<li><a href="#orgbb143dc">Apply-op</a></li>
<li><a href="#org7b13f0e">find-all</a></li>
</ul>
</li>
<li><a href="#org4dde66a">Problems</a>
<ul>
<li><a href="#orgbf4d3a8">Running Around the Block Problem</a></li>
<li><a href="#org3fc8f85">Clobbered Sibling Goal Problem</a></li>
<li><a href="#org1d271fc">Leaping Before Looking Problem</a></li>
<li><a href="#orge0c4d95">Recursive Subgoals  Problem</a></li>
<li><a href="#orgc9a0b89">Lack of Intermediate Information</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org44b30fd">VERSION TWO</a>
<ul>
<li><a href="#orga1f3498">GPS Debugger</a></li>
<li><a href="#orgf35a2d4">Glossary</a></li>
<li><a href="#org26406e9">GPS</a>
<ul>
<li><a href="#org1e520ff">Simple GPS</a></li>
<li><a href="#orgc474e0e">GPS Updating Dynamic State</a></li>
</ul>
</li>
<li><a href="#org30e0712">Special Variables</a></li>
<li><a href="#org72aa19a">Data Structure</a></li>
<li><a href="#orga6219f6">Major Functions</a>
<ul>
<li><a href="#org51b2be2">Achieve-all</a></li>
<li><a href="#org56b84f8">Achieve</a></li>
<li><a href="#orgecf8703">Appropriate-p</a></li>
<li><a href="#org2e6c598">Apply-op</a></li>
</ul>
</li>
<li><a href="#org3e90946">Auxiliary Functions</a>
<ul>
<li><a href="#org553fbd8">executing-p</a></li>
<li><a href="#org4a687cd">starts-with</a></li>
<li><a href="#org9dc95b1">convert-op</a></li>
<li><a href="#org9cb8d80">op</a></li>
<li><a href="#org8634449">use</a></li>
<li><a href="#orgd9d87fb">member-equal</a></li>
</ul>
</li>
<li><a href="#orga2a3fa2">Previously Defined Functions</a></li>
</ul>
</li>
<li><a href="#org0205f49">VERSION THREE</a>
<ul>
<li><a href="#org372d1f8">GPS</a></li>
<li><a href="#orga931d0b">Action-p</a></li>
<li><a href="#orgf262409">Previously defined functions</a></li>
</ul>
</li>
<li><a href="#org6e82005">KNOWLEDGE BASES</a>
<ul>
<li><a href="#org2e51ee2">Parameterize knowledge base</a></li>
<li><a href="#org851f5a5">School Ops</a></li>
<li><a href="#org771b089">Banana Ops</a></li>
<li><a href="#org1c6b0ba">Maze Ops</a>
<ul>
<li><a href="#orgac3f98b">make-maze-ops</a></li>
<li><a href="#org60ef23b">make-maze-op</a></li>
<li><a href="#org039191d">Using Maze Ops in Another Program</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3bcabad">TESTING CODE</a>
<ul>
<li><a href="#org5c65e2e">GPSv1 School Ops</a></li>
<li><a href="#org0b40c48">GPSv2 Monkey Ops</a></li>
<li><a href="#orgedf02b3">GPSv3 Maze Ops</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8eea4e2" class="outline-2">
<h2 id="org8eea4e2">PREFACE</h2>
<div class="outline-text-2" id="text-org8eea4e2">
<p>
<b><b>The computer code here is not original to me.</b></b> and this document reflects several of my ongoing projects:
</p>
<ol class="org-ol">
<li>Learning 'classic' AI by working through Peter Norvig's <a href="http://norvig.com/paip.html"><b>Paradigms of Artificial Intelligence: Case Studies in Common Lisp</b></a>.   Norvig's book is the source for the Lisp code in this project.</li>
<li>Learning more Emacs in general and org-mode in particular.</li>
<li>Developing a work process around Literate Programming.</li>
</ol>
</div>
</div>
<div id="outline-container-org0f11e90" class="outline-2">
<h2 id="org0f11e90">INTRODUCTION</h2>
<div class="outline-text-2" id="text-org0f11e90">
<p>
The General Problem Solver was developed in 1957 by <a href="https://en.wikipedia.org/wiki/Allen_Newell">Alan Newell</a>, <a href="https://en.wikipedia.org/wiki/Cliff_Shaw">Cliff Shaw</a> and <a href="https://en.wikipedia.org/wiki/Herbert_A._Simon">Herbert Simon</a>. The paper associated with their initial work is <a href="http://bitsavers.informatik.uni-stuttgart.de/pdf/rand/ipl/P-1584_Report_On_A_General_Problem-Solving_Program_Feb59.pdf"><b>A Report on a General Problem Solving Program</b></a>. However, the code in this version is based on Chapter 4 of <a href="http://norvig.com/paip.html"><b>Paradigms of Artificial Intelligence: Case Studies in Common Lisp</b></a>.
</p>

<p>
Outside of historical value, the General Problem Solver is deemed a failure due to the likelihood of combinatorial explosion. But as I work through the code base, I can't help but appreciate the soundness of its program structure and logic&#x2026;it was developed years before the discovery of NP-hard and it seems like an approach that at least allows for solving simple problems in a straight forward way. This is due, I think to the quality of its abstractions over state and mutating it.
</p>
</div>

<div id="outline-container-orge759882" class="outline-3">
<h3 id="orge759882">GPS Main Components</h3>
<div class="outline-text-3" id="text-orge759882">
<ol class="org-ol">
<li>A vocabulary for talking about the task environment: operators, objects, difference, feature, etc.</li>
<li>A vocabulary for dealing with the organization of problem-solving processes: goal, method, evaluation.</li>
<li>Programs defining the terms of the problem solving vocabulary in terms of the task environment vocabulary.</li>
<li>A set of correlative definitions applying the task-environment vocabulary to a particular domain environment.</li>
</ol>
</div>
</div>
<div id="outline-container-orgd98b1e1" class="outline-3">
<h3 id="orgd98b1e1">Goal Types</h3>
<div class="outline-text-3" id="text-orgd98b1e1">
<ol class="org-ol">
<li>Transform <code>object a</code> into <code>object b</code> by applying operators from the task environment. An example is proof from axioms.</li>
<li>Apply <code>operator q</code> to <code>object a</code> or an object obtained from a by admissible transformations. An example is integrating an expression.</li>
<li>Reduce the difference (distance) between <code>object a</code> and <code>object b</code> by transforming <code>object a</code>.</li>
</ol>
</div>
</div>
<div id="outline-container-org3161808" class="outline-3">
<h3 id="org3161808">Heuristics</h3>
<div class="outline-text-3" id="text-org3161808">
<p>
The main heuristic is the principle of sub-goal reduction: reduce hard goals to sets of easier goals. This assumes that the difference between the current state and the goal can be determined; operators have partial effects on the environment and some portions always remain unchanged by each operator; some differences are harder to effect than others and so it is good practice to eliminate hard differences at the cost of introducing easier differences so long as progress is made.
</p>
</div>
</div>

<div id="outline-container-orgecb5503" class="outline-3">
<h3 id="orgecb5503">Executive Structure of GPS</h3>
<div class="outline-text-3" id="text-orgecb5503">
<p>
Make the diagram using Graphviz's Dot language.
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph G {
size="5,5";
ratio=1.1;
a[label="Command to\nachieve goal", shape=plaintext];
b[label="Evaluate Goal", shape=box];
bb[label="Do not try\nto achieve", shape=plaintext];
c[label="Select method\nfor this type of goal", shape=box];
d[label="Execute method", shape=box];
e[label="Goal achieved", shape=plaintext];
splines=ortho;
{
a -&gt; b -&gt; c -&gt; d -&gt; e;
}
rank=same {b, bb}
b:e -&gt; bb:w [label="Reject"];
d:w -&gt; b:w [xlabel="Goal\nnot\nachieved", constraint=false];
}
</pre>
</div>


<div class="figure">
<p><img src="gps-exec.png" alt="gps-exec.png" />
</p>
</div>

<p>
<i>Source code for this diagram is written in</i> <code>graphviz</code> <i>and contained in the literate programming file.</i>
</p>
</div>
</div>
</div>

<div id="outline-container-org275c35e" class="outline-2">
<h2 id="org275c35e">PROCESS STAGES</h2>
<div class="outline-text-2" id="text-org275c35e">
</div><div id="outline-container-org332dc41" class="outline-3">
<h3 id="org332dc41">Description</h3>
<div class="outline-text-3" id="text-org332dc41">
<p>
The description of problem solving uses the theory of means-ends analysis. The problem is stated in terms of what we want to happen and look at the difference between what we want and what we have. Some actions have preconditions.
</p>
</div>
</div>
<div id="outline-container-org2ee055c" class="outline-3">
<h3 id="org2ee055c">Specification</h3>
<div class="outline-text-3" id="text-org2ee055c">
<p>
The specification has seven parts.
</p>
<ul class="org-ul">
<li>Represent the current state of the world (environment) as a set of conditions. Represent the desired state of the world as a set of conditions.</li>
<li>A list of allowable operators.</li>
<li>Each operator is: a list of preconditions, an action, a list of effects.</li>
<li>A complete problem is a starting state, a goal state, a set of known operators.</li>
<li>A goal condition can be achieved two ways: it is in the current state or by applying an operator to the current environment.</li>
<li>An operator is appropriate if it adds the goal to the environment.</li>
<li>An operator can be applied if all the preconditions for its application can be met.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org268e224" class="outline-2">
<h2 id="org268e224">VERSION ONE</h2>
<div class="outline-text-2" id="text-org268e224">
<p>
This is the first iteration of GPS from Norvig's book. It is an exercise to get something to run, but it has problems that are discussed at the end of this section. There is a second version of GPS provided in the next section. 
</p>
</div>
<div id="outline-container-orgf756a22" class="outline-3">
<h3 id="orgf756a22">Implementation</h3>
<div class="outline-text-3" id="text-orgf756a22">
</div><div id="outline-container-org5494d1a" class="outline-4">
<h4 id="org5494d1a">Glossary</h4>
<div class="outline-text-4" id="text-org5494d1a">
<!-- This HTML table template is generated by emacs 25.1.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Top&nbsp;Level&nbsp;Function*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      GPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solve&nbsp;a&nbsp;goal&nbsp;from&nbsp;a&nbsp;state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;a&nbsp;list&nbsp;of&nbsp;operators.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>
<div id="outline-container-orgd220586" class="outline-4">
<h4 id="orgd220586">GPS</h4>
<div class="outline-text-4" id="text-orgd220586">
<p>
For literate programming purposes the source block name had to use 'one' instead of '1' to work with <code>:noweb</code>.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgf3efd2a">;;; THIS FILE AUTOGENERATATED

;;; Helper Function
&lt;&lt;find-all-v-one&gt;&gt;

;;; Special Variables
&lt;&lt;special-variables-v-one&gt;&gt;

;;; Operations
&lt;&lt;op-v-one&gt;&gt;

;;; Main
  (defun gps (*state* goals *ops*)
    "General Problem Solver: achieve all goals using *ops*."
    (if (every #'achieve goals) 'solved))

;;; Functions
&lt;&lt;achieve-v-one&gt;&gt;

&lt;&lt;appropriate-p-v-one&gt;&gt;

&lt;&lt;apply-op-v-one&gt;&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-org11dd041" class="outline-4">
<h4 id="org11dd041">Special Variables</h4>
<div class="outline-text-4" id="text-org11dd041">
<div class="org-src-container">
<pre class="src src-lisp" id="orged1ff33">(defvar *state* nil "The current state: a list of all conditions.")
(defvar *ops* nil "A list of available operations.")
</pre>
</div>
</div>
</div>

<div id="outline-container-org90c555e" class="outline-4">
<h4 id="org90c555e">Op Data Structure</h4>
<div class="outline-text-4" id="text-org90c555e">
<p>
Note that <code>nil</code> is the default value for each field of the <code>op</code> structure. 
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org1a84906">(defstruct op
  "An operation."
  (action nil)
  (preconds nil)
  (add-list nil)
  (del-list nil))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga065ad1" class="outline-4">
<h4 id="orga065ad1">Achieve</h4>
<div class="outline-text-4" id="text-orga065ad1">
<div class="org-src-container">
<pre class="src src-lisp" id="org4118db7">(defun achieve (goal)
  "A goal is achieved if it already holds. Or if there
   is an appropriate op for it that is applicable."
  (or (member goal *state*)
      (some #'apply-op
            (find-all goal *ops* :test #'appropriate-p))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga02ae0c" class="outline-4">
<h4 id="orga02ae0c">Appropriate-p</h4>
<div class="outline-text-4" id="text-orga02ae0c">
<div class="org-src-container">
<pre class="src src-lisp" id="org2d0501a">(defun appropriate-p (goal op)
  "An op is appropriate to a goal if the goal is on the op's add-list."
  (member goal (op-add-list op)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbb143dc" class="outline-4">
<h4 id="orgbb143dc">Apply-op</h4>
<div class="outline-text-4" id="text-orgbb143dc">
<div class="org-src-container">
<pre class="src src-lisp" id="orge1d849f">(defun apply-op (op)
  "Print a message and update *state* when op is applicable."
  (when (every #'achieve (op-preconds op))
    (print (list 'executing (op-action op)))
    (setf *state* (set-difference *state* (op-del-list op)))
    (setf *state* (union *state* (op-add-list op)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org7b13f0e" class="outline-4">
<h4 id="org7b13f0e">find-all</h4>
<div class="outline-text-4" id="text-org7b13f0e">
<p>
<code>FIND-ALL</code> is introduced early in the book and provides an example of a user function that has many of the features of a Common Lisp built-in function.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org9368cb5">(defun find-all (item sequence &amp;rest keyword-args
                               &amp;key (test #'eql)
                               test-not
                               &amp;allow-other-keys)
  "Find all those elements of sequence that match item.
   according to the keywords. Does not alter sequence"
  (if test-not
      (apply #'remove item sequence
             :test-not (complement test-not) keyword-args)
      (apply #'remove item sequence
             :test (complement test) keyword-args)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4dde66a" class="outline-3">
<h3 id="org4dde66a">Problems</h3>
<div class="outline-text-3" id="text-org4dde66a">
</div><div id="outline-container-orgbf4d3a8" class="outline-4">
<h4 id="orgbf4d3a8">Running Around the Block Problem</h4>
<div class="outline-text-4" id="text-orgbf4d3a8">
<p>
Version One does not handle the run for the side effects case where the start state and the end state are the same&#x2026;e.g. if we run around the block for exercise.
</p>
</div>
</div>
<div id="outline-container-org3fc8f85" class="outline-4">
<h4 id="org3fc8f85">Clobbered Sibling Goal Problem</h4>
<div class="outline-text-4" id="text-org3fc8f85">
<p>
The code only checks if each goal requirement is achieved at some point, therefore
</p>
<div class="org-src-container">
<pre class="src src-lisp">(gps '(son-at-home car-needs-battery have-money have-phone-book)
     '(have-money son-at-school)
     *school-ops*)

=&gt; SOLVED
</pre>
</div>
<p>
Despite repairing the car using all the money.
</p>
</div>
</div>
<div id="outline-container-org1d271fc" class="outline-4">
<h4 id="org1d271fc">Leaping Before Looking Problem</h4>
<div class="outline-text-4" id="text-org1d271fc">
<p>
GPS will choose a course of action and continue it regardless of whether it will solve the problem. Even worse, it will not back up and try a different approach after hitting a dead end.
</p>
</div>
</div>
<div id="outline-container-orge0c4d95" class="outline-4">
<h4 id="orge0c4d95">Recursive Subgoals  Problem</h4>
<div class="outline-text-4" id="text-orge0c4d95">
<p>
It is possible to create operations which will send GPS into an infinite loop.
</p>
</div>
</div>
<div id="outline-container-orgc9a0b89" class="outline-4">
<h4 id="orgc9a0b89">Lack of Intermediate Information</h4>
<div class="outline-text-4" id="text-orgc9a0b89">
<p>
GPS will report failure but only as <code>NIL</code>. It will not report what it tried.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org44b30fd" class="outline-2">
<h2 id="org44b30fd">VERSION TWO</h2>
<div class="outline-text-2" id="text-org44b30fd">
<p>
At one level, adding GPSv2 into this same source file is kind of a mess. But it makes for a richer exercise from an Emacs/Org-Babel/Literate Programming perspective. It certainly pushes me to understand more about the topic and makes for a more robust documentation of the project's development.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org7912137">;; This file was auto generated from
;; general-problem-solver.org

&lt;&lt;load-gps-debugger-v-two&gt;&gt;

&lt;&lt;gps-v-two-simple&gt;&gt;

&lt;&lt;special-variables-v-two&gt;&gt;

&lt;&lt;op-v-two&gt;&gt;

&lt;&lt;major-functions-v-two&gt;&gt;

&lt;&lt;auxiliary-functions-v-two&gt;&gt;

&lt;&lt;previously-defined-functions-v-two&gt;&gt;
</pre>
</div>
</div>
<div id="outline-container-orga1f3498" class="outline-3">
<h3 id="orga1f3498">GPS Debugger</h3>
<div class="outline-text-3" id="text-orga1f3498">
<p>
The first of the problems with <code>Version One</code> to be addressed is the Lack of Intermediate Information. Using a debugger seems like a reasonable approach: <code>using-a-debugger</code> requires <code>having-a-debugger</code> and <code>having-a-debugger</code> requires <code>writing-a-debugger</code>. It's what I love about this book, it's GPS all the way down.
</p>

<p>
The debugger is named <code>gps-debug</code> to avoid conflict with SBCL. To use <code>(gps-debug :gps :some-other-symbol :etc)</code>. To turn debugging off <code>(gps-debug)</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org2a5b13b">(defvar *dbg-ids* nil
  "Identifiers used by dbg")

(defun dbg (id format-string &amp;rest args)
  "Print debugging information if (DEBUG-ID) has been specified."
  (when (member id *dbg-ids*)
    (fresh-line *debug-io*)
    (apply #'format *debug-io* format-string args)))

;;; Using gps-debug because 'debug' reserved in SBCL
(defun gps-debug (&amp;rest ids)
  "Start dbg output on the given ids."
  (setf *dbg-ids* (union ids *dbg-ids*)))

(defun undebug (&amp;rest ids)
  "Stop dbg on the ids. With no ids, stop debugging altogether."
  (setf *dbg-ids* (if (null ids) nil
                    (set-difference *dbg-ids* ids))))

(defun dbg-indent (id indent format-string &amp;rest args)
  "Print indented debugging info if (DEBUG ID) has been specified."
  (when (member id *dbg-ids*)
    (fresh-line *debug-io*)
    (dotimes (i indent) (princ "   " *debug-io*))
    (apply #'format *debug-io* format-string args)))
</pre>
</div>
<p>
For the current project, I am just going to <code>load</code> the debugger into GPSv2 rather than setting up ASDF&#x2026;because my head is not quite wrapped around ASDF yet in terms of how it would work with this project.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org8cf8197">(load "gps-debugger.lisp")
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf35a2d4" class="outline-3">
<h3 id="orgf35a2d4">Glossary</h3>
<div class="outline-text-3" id="text-orgf35a2d4">
<!-- This HTML table template is generated by emacs 25.1.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Top&nbsp;Level&nbsp;Function*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      GPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solve&nbsp;a&nbsp;goal&nbsp;from&nbsp;a&nbsp;state&nbsp;using&nbsp;a&nbsp;list&nbsp;of&nbsp;operators.&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Special&nbsp;Variables*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      *ops*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;List&nbsp;of&nbsp;available&nbsp;operators.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Data&nbsp;Types*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;operation&nbsp;with&nbsp;preconds,&nbsp;add-list,&nbsp;del-list.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Major&nbsp;Functions*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      achieve-all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Achieve&nbsp;a&nbsp;list&nbsp;of&nbsp;goals.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      achieve&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Achieve&nbsp;a&nbsp;single&nbsp;goal.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      appropriate-p&nbsp;&nbsp;&nbsp;Decide&nbsp;if&nbsp;an&nbsp;operator&nbsp;is&nbsp;appropriate&nbsp;to&nbsp;a&nbsp;goal.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      apply-op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apply&nbsp;operator&nbsp;to&nbsp;current&nbsp;state.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Auxiliary&nbsp;Functions*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      executing-p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;condition&nbsp;an&nbsp;executing&nbsp;form?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      starts-with&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;the&nbsp;argument&nbsp;a&nbsp;list&nbsp;that&nbsp;starts&nbsp;with&nbsp;a&nbsp;given&nbsp;atom?&nbsp;&nbsp;<br />
      convert-op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert&nbsp;an&nbsp;operator&nbsp;to&nbsp;use&nbsp;the&nbsp;executing&nbsp;convention.&nbsp;&nbsp;&nbsp;<br />
      op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create&nbsp;an&nbsp;operator.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      use&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;a&nbsp;list&nbsp;of&nbsp;operators.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      member-equal&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;an&nbsp;element&nbsp;is&nbsp;equal&nbsp;to&nbsp;a&nbsp;member&nbsp;of&nbsp;a&nbsp;list.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Selected&nbsp;Common&nbsp;Lisp&nbsp;Functions*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      member&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;an&nbsp;element&nbsp;is&nbsp;a&nbsp;member&nbsp;of&nbsp;a&nbsp;list.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      set-difference&nbsp;&nbsp;All&nbsp;elements&nbsp;in&nbsp;one&nbsp;set&nbsp;but&nbsp;not&nbsp;in&nbsp;the&nbsp;other.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      subsetp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;one&nbsp;set&nbsp;wholly&nbsp;contained&nbsp;in&nbsp;another?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      union&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All&nbsp;elements&nbsp;in&nbsp;either&nbsp;of&nbsp;two&nbsp;sets.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      every&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;every&nbsp;element&nbsp;of&nbsp;a&nbsp;list&nbsp;passes&nbsp;test.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      some&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;any&nbsp;element&nbsp;of&nbsp;a&nbsp;list&nbsp;passes&nbsp;test.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      remove-if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove&nbsp;all&nbsp;items&nbsp;satisfying&nbsp;a&nbsp;test.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-org26406e9" class="outline-3">
<h3 id="org26406e9">GPS</h3>
<div class="outline-text-3" id="text-org26406e9">
<p>
Norvig provides two alternative implementations of <code>gps</code> in GPSv2. The first is largely similar to GPSv1 with the addition of the goal stack and a <code>start</code> state and treating the parameters as an optional argument which otherwise defaults to the dynamic scope of <code>*ops*</code>. I think adding a <code>start</code> state makes GPS more straight forward in terms of automata theory.
</p>
</div>
<div id="outline-container-org1e520ff" class="outline-4">
<h4 id="org1e520ff">Simple GPS</h4>
<div class="outline-text-4" id="text-org1e520ff">
<div class="org-src-container">
<pre class="src src-lisp" id="org288f0af">(defun gps (state goals &amp;optional (*ops* *ops*))
  "General Problem Solver: from state achieves goals using *ops*."
  (remove-if #'atom (achieve-all (cons '(start) state) goals nil)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc474e0e" class="outline-4">
<h4 id="orgc474e0e">GPS Updating Dynamic State</h4>
<div class="outline-text-4" id="text-orgc474e0e">
<p>
The second implementation of GPSv2, in addition to accepting the operations as an optional argument also updates the global parameter <code>*ops*</code> to match the argument if it is supplied. Norvig says this is more complicated but useful without explaining why. I suspect it is more useful in the case of more advanced agents (or multiple agents) where the availble operations change during program execution.
</p>

<p>
As I was entering the code, I kind of choked for a second on the documentation string; thinking shouldn't it be 'using ops'. But then I realized that since <code>*ops*</code> quickly becomes <code>ops</code>, it made sense. It's the sort of subtle understanding that only comes from really working with the code in a textbook. No matter how much I read, without typing, I'd never have had that thought. Then after typing the code, I saw that this version cleans up after itself by restoring the old value of <code>*ops*</code> before returning the result. It's a sort of manual shadowing of variables. Probably problematic in a concurrent environment, but one <i>general problem</i> at a time.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgc24f6a6">(defun gps (state goals &amp;optional (ops *ops*))
  "General Problem Solver: from state achieve goals using *ops*."
  (let ((lod-ops *ops*))
    (setf *ops* ops)
    (let ((result (remove-if #'atom
                             (achieve-all (cons '(start) state)
                                          goals
                                          nil))))
      (setf *ops* old-ops)
      result)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org30e0712" class="outline-3">
<h3 id="org30e0712">Special Variables</h3>
<div class="outline-text-3" id="text-org30e0712">
<p>
GPS Version Two handles state differently than version one and so only requires the <code>*ops*</code> parameter. The <code>*ops*</code> parameter allows the creation of different applications based on the use of different operations. This ability is what puts the 'general' in GPS.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgfd77846">(defvar *ops* nil "A list of available operators.")
</pre>
</div>
</div>
</div>
<div id="outline-container-org72aa19a" class="outline-3">
<h3 id="org72aa19a">Data Structure</h3>
<div class="outline-text-3" id="text-org72aa19a">
<p>
The <code>op</code> data structure is not changed from version one so we can reuse it. But I'll still make a source code block to make changes easier in the future.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgd040ad4">&lt;&lt;op-v-one&gt;&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-orga6219f6" class="outline-3">
<h3 id="orga6219f6">Major Functions</h3>
<div class="outline-text-3" id="text-orga6219f6">
<div class="org-src-container">
<pre class="src src-lisp" id="org8fda675">;;; Major Functions

&lt;&lt;achieve-all-v-two&gt;&gt;

&lt;&lt;achieve-v-two&gt;&gt;

&lt;&lt;appropriate-p-v-two&gt;&gt;

&lt;&lt;apply-op-v-two&gt;&gt;
</pre>
</div>
<p>
The only additional function for GPS Version 2 is the addition of <code>achieve-all</code>. However, the other functions: <code>achieve</code>, <code>appropriate-p</code>, and <code>apply-op</code> are modified.
</p>
</div>
<div id="outline-container-org51b2be2" class="outline-4">
<h4 id="org51b2be2">Achieve-all</h4>
<div class="outline-text-4" id="text-org51b2be2">
<p>
Achieve all is Norvig's solution to the clobbered sibling goal. It makes ensures that after achieving the goals, all the goals are still in the current state of the world. 
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgdade7dc">(defun achieve-all (state goals goal-stack)
  "Try to achieve each goal and make sure each still holds at the end."
  (let ((current-state state))
    (if (and (every #'(lambda (g)
                        (setf current-state
                              (achieve current-state g goal-stack)))
                    goals)
             (subsetp goals current-state :test #'equal))
        current-state)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org56b84f8" class="outline-4">
<h4 id="org56b84f8">Achieve</h4>
<div class="outline-text-4" id="text-org56b84f8">
<p>
The new version of <code>achieve</code> is designed to handle the recursive subgoal problem. It uses a 'goal stack' to check if the current goal has become a sub-goal of itself. It also adds debugging.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgd7eedac">(defun achieve (state goal goal-stack)
  "A goal is achieved if:\n  It already holds\n  Or\n There is an applicable appropriate op."
  (dbg-indent :gps (length goal-stack) "Goal: ~a" goal)
  (cond ((member-equal goal state) state)
        ((member-equal goal goal-stack) nil)
        (t (some #'(lambda (op)
                     (apply-op state goal op goal-stack))
                 (find-all goal *ops* :test #'appropriate-p)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgecf8703" class="outline-4">
<h4 id="orgecf8703">Appropriate-p</h4>
<div class="outline-text-4" id="text-orgecf8703">
<p>
The change for GPSv2 is to use <a href="#org0af54d9"><code>member-equal</code></a> when looking for a goal in an <code>op-add-list</code>. The problem arises because in GPLv2 goals can be lists rather than symbols: for example <code>'(executing run-around-block)</code>. 
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org0ff25df">(defun appropriate-p (goal op)
  "An op is approriate to a goal if the goal is in the op's add list."
  (member-equal goal (op-add-list op)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2e6c598" class="outline-4">
<h4 id="org2e6c598">Apply-op</h4>
<div class="outline-text-4" id="text-org2e6c598">
<p>
GPLv2 uses a more sophisticated application mechanism and most of it is reflected in changes to <code>apply-op</code>. One the one hand, the mechanism is more 'functional': <code>apply-op</code> now takes a state and returns a state rather than mutating a global state. On the other hand, the logic runs deeper and does more.
</p>

<p>
It also adds debugging and replaces the set oriented functions <code>union</code> and <code>set-diff</code> with order preserving functions <code>append</code> and <code>remove-if</code>. Once the 'executing' syntax was added, time became a bigger part of the model.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgf5e13d1">(defun apply-op (state goal op goal-stack)
  "Return a new state that is a transformation of the input state when op is applicable."
  (dbg-indent :gps (length goal-stack) "Consider: ~a" (op-action op))
  (let ((state2 (achieve-all state
                             (op-preconds op)
                             (cons goal goal-stack))))
    (unless (null state2)
      ;; return an updated state
      (dbg-indent :gps (length goal-stack) "Action: ~a" (op-action op))
      (append (remove-if #'(lambda (x)
                             (member-equal x (op-del-list op)))
                         state2)
              (op-add-list op)))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3e90946" class="outline-3">
<h3 id="org3e90946">Auxiliary Functions</h3>
<div class="outline-text-3" id="text-org3e90946">
<p>
These functions implement a new form for ops so that the action list contains an "executing" action to address the running around the block problem. There is also a conversion function to back port the changed structure to <b>school-ops</b>.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org9557566">&lt;&lt;executing-p-v-two&gt;&gt;

&lt;&lt;starts-with-v-two&gt;&gt;  

&lt;&lt;convert-op-v-two&gt;&gt;

&lt;&lt;op-function-v-two&gt;&gt;

&lt;&lt;member-equal-v-two&gt;&gt;

&lt;&lt;use-v-two&gt;&gt;
</pre>
</div>
</div>
<div id="outline-container-org553fbd8" class="outline-4">
<h4 id="org553fbd8">executing-p</h4>
<div class="outline-text-4" id="text-org553fbd8">
<p>
The idea that a goal can consist merely of executing some action between to identical (for our purpose) states of the world makes the model richer. It also comes with additional complexity.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgf391483">(defun executing-p (x)
  "Is the form: (executing...)?"
  (starts-with x 'executing))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4a687cd" class="outline-4">
<h4 id="org4a687cd">starts-with</h4>
<div class="outline-text-4" id="text-org4a687cd">
<p>
Making sure that an object is a list before trying to look at its <code>first</code> element avoids some nasty crashes. Abstracting over the details with a function is a good idea.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgd72cc56">(defun starts-with (list x)
    "Is this a list whose first element is x?"
    (and (consp list)
         (eql (first list) x)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9dc95b1" class="outline-4">
<h4 id="org9dc95b1">convert-op</h4>
<div class="outline-text-4" id="text-org9dc95b1">
<p>
It's a good idea to be able to backport the new executing syntax to the earlier <code>*school-ops*</code> knowledge base. Writing a simple function to iteratively improve the app is probably easier than trying to get it right the first time&#x2026;or at least I'm going with Norvig on that idea.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgc65a105">(defun convert-op (op)
  "Make op conform to the (EXECUTING op) convention."
  (unless (some #'executing-p (op-add-list op))
    (push (list 'executing (op-action op))
          (op-add-list op)))
  op)
</pre>
</div>
</div>
</div>
<div id="outline-container-org9cb8d80" class="outline-4">
<h4 id="org9cb8d80">op</h4>
<div class="outline-text-4" id="text-org9cb8d80">
<p>
It's nice to have a bit easier semantics for making new <code>op</code>'s. So why not add a function? Well in a Lisp-1 that would be a mess and here it is just a potential bit of confusion.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgcf85f52">(defun op (action &amp;key preconds add-list del-list)
  "Make a new operator that obeys the (EXECUTING op) convention."
  (make-op :action action
           :preconds preconds
           :add-list add-list
           :del-list del-list))
</pre>
</div>
</div>
</div>
<div id="outline-container-org8634449" class="outline-4">
<h4 id="org8634449">use</h4>
<div class="outline-text-4" id="text-org8634449">
<p>
To better facilitate management of parameters the new versions of <code>gps</code> allow operations (i.e. the value of the dynamic variable <code>*ops*</code> to be passed as an optional parameter. Better management of <code>*ops*</code> is provided by <code>use</code>. It provides a simpler way to reparameterize the application.
</p>

<p>
The technique of returning the length of the return value (i.e. the length of <code>oplist</code>) ensures that the <code>use</code> returns a true value even when <code>oplist</code> is the empty list. Without the use of <code>length</code> the call <code>(setf *ops* nil)</code> would return <code>nil</code> and evaluate to <code>false</code>. Using <code>length</code> an integer will always be returned if the call was successful and even the integer <code>0</code> will evaluate to <code>true</code> in Common Lisp.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org0a95b0b">(defun use (oplist)
  "Use oplist as the default set of operators by setting the dynamic variable *ops* to its value."
  ;; Return something useful
  ;; but not verbose
  (length (setf *ops* oplist)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd9d87fb" class="outline-4">
<h4 id="orgd9d87fb">member-equal</h4>
<div class="outline-text-4" id="text-orgd9d87fb">
<p>
Lists are only <code>eq</code> when they share structure and <code>eq</code> is the default for <code>member</code>. A new function helps deal with the <code>executing</code> syntax.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org0af54d9">(defun member-equal (item list)
  "Test for membership in a list as set using equal."
  (member item list :test #'equal))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga2a3fa2" class="outline-3">
<h3 id="orga2a3fa2">Previously Defined Functions</h3>
<div class="outline-text-3" id="text-orga2a3fa2">
<p>
The function <code>find-all</code> does not change from GPS Version One. Norvig uses <code>find-all-if</code> as an example of naming clarifying a potential use case earlier in the book. In hindsight the use case seems obvious, but there's kinda/sorta a double negative in <code>remove-if-not</code> standing in the way.
</p>

<p>
On the other hand, it's not clear how different this is from <code>find-all</code> beyond being based on a built-in function rather than one written by the user.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org0a9ac6e">&lt;&lt;find-all-v-one&gt;&gt;
(setf (symbol-function 'find-all-if) #'remove-if-not)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0205f49" class="outline-2">
<h2 id="org0205f49">VERSION THREE</h2>
<div class="outline-text-2" id="text-org0205f49">
<p>
The third version of GPS fixes a bug related to assuming that each action is an <code>atom</code>. Because the actions for <code>*maze-ops* are compound in the form of ='(at &lt;location&gt;)</code> this assumption no longer holds. Norvig calls the problem of using a method that is convenient instead of a method that follows the business logic 'punning'. Essentially, it is calling a function that is at the wrong level of abstraction. Here we want an <code>'executing</code> form from the GPS 'language' not the <code>atom</code> form from Common Lisp.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="orgca16840">;; This file was auto generated from
;; general-problem-solver.org

&lt;&lt;load-gps-debugger-v-two&gt;&gt;

&lt;&lt;action-p&gt;&gt;

&lt;&lt;gps-v-three&gt;&gt;

&lt;&lt;special-variables-v-two&gt;&gt;

&lt;&lt;op-v-two&gt;&gt;

&lt;&lt;major-functions-v-two&gt;&gt;

&lt;&lt;auxiliary-functions-v-two&gt;&gt;

&lt;&lt;previously-defined-functions-v-three&gt;&gt;
</pre>
</div>
</div>
<div id="outline-container-org372d1f8" class="outline-3">
<h3 id="org372d1f8">GPS</h3>
<div class="outline-text-3" id="text-org372d1f8">
<div class="org-src-container">
<pre class="src src-lisp" id="orgd4ed41b">(defun gps (state goals &amp;optional (*ops* *ops*))
  "General Problem Solver: from state, achieve goals using *ops*."
  (find-all-if #'action-p
               (achieve-all (cons '(start) state) goals nil)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga931d0b" class="outline-3">
<h3 id="orga931d0b">Action-p</h3>
<div class="outline-text-3" id="text-orga931d0b">
<p>
Any solution will be a path through the state space that starts with <code>(start)</code> and has zero or more <code>(executing...)</code> elements.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org314c3e9">(defun action-p (x)
  "Is x something that is (start) or (executing...)?"
  (or (equal x '(start))
      (executing-p x)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf262409" class="outline-3">
<h3 id="orgf262409">Previously defined functions</h3>
<div class="outline-text-3" id="text-orgf262409">
<p>
Norvig introduces <code>mappend</code> early on [page 19]. But not having it in the environment didn't bite me in the ass until more than 100 pages later when I implemented <code>*maze-ops*</code>. On the other hand, coming back and revisiting it more than a month after starting to look at Common Lisp again made it much more obvious than it was in my glazed state at the beginning of the book.
</p>

<p>
At the <code>org-mode</code> level, I sort of like the fact it forced me to tangle incrementally. I haven't really been doing that and being comfortable just referencing version-two is a nice change to my attitude.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org2160603">&lt;&lt;previously-defined-functions-v-two&gt;&gt;

(defun mappend (fn the-list)
  "Apply function to each element of the list and append the results."
  (apply #'append (mapcar fn the-list)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6e82005" class="outline-2">
<h2 id="org6e82005">KNOWLEDGE BASES</h2>
<div class="outline-text-2" id="text-org6e82005">
</div><div id="outline-container-org2e51ee2" class="outline-3">
<h3 id="org2e51ee2">Parameterize knowledge base</h3>
<div class="outline-text-3" id="text-org2e51ee2">
<p>
This is one of the techniques that Norvig introduces early in the book. The idea of parameters is that changing the parameters, creates a different program. For example, the school parameters here create a program that solves the problem of getting the son to school. A different set of parameters will create a 'different' problem solver.
</p>
</div>
</div>
<div id="outline-container-org851f5a5" class="outline-3">
<h3 id="org851f5a5">School Ops</h3>
<div class="outline-text-3" id="text-org851f5a5">
<p>
The parameter <code>*school-ops*</code> could be shorter by leaving out the fields that are <code>nil</code> since it is the default for the <code>op</code> structure and Norvig does so in the book.  However, being explicit has the advantage of requiring less local knowledge and the advantage of creating a more regular pattern within the code similar to the design recipes in <b>How to Design Programs</b>.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org6cfc07a">(defparameter *school-ops*
  (mapcar #'convert-op
          (list
           (make-op
            :action 'drive-son-to-school
            :preconds '(son-at-home car-works)
            :add-list '(son-at-school)
            :del-list '(son-at-home))
           (make-op
            :action 'shop-installs-battery
            :preconds '(car-needs-battery shop-knows-problem shop-has-money)
            :add-list '(car-works)
            :del-list nil)
           (make-op
            :action 'tell-shop-problem
            :preconds '(in-communication-with-shop)
            :add-list '(shop-knows-problem)
            :del-list 'nil)
           (make-op
            :action 'telephone-shop
            :preconds '(know-phone-number)
            :add-list '(in-communication-with-shop)
            :del-list nil)
           (make-op
            :action 'look-up-number
            :preconds '(have-phone-book)
            :add-list '(know-phone-number)
            :del-list nil)
           (make-op
            :action 'give-shop-money
            :preconds '(have-money)
            :add-list '(shop-has-money)
            :del-list '(have-money)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org771b089" class="outline-3">
<h3 id="org771b089">Banana Ops</h3>
<div class="outline-text-3" id="text-org771b089">
<p>
The interesting thing about <code>*banana-ops*</code> is how arbitrary the knowledge representation feels. Conditions like <code>'hungry</code> feel like a different level of abstraction than <code>'empty-handed</code> or <code>chair-at-middle-room</code>. I suppose it is because the monkey seems like an agent and <code>'hungry</code> is an internal state while other operators reflect its environment. I suppose I am expecting a more anthropromorphic perspective that just isn't in GPS.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org5f2eb0b">(defparameter *banana-ops*
  (mapcar #'convert-op
          (list
           (op 'climb-on-chair
               :preconds '(chair-at-middle-room at-middle-room on-floor)
               :add-list '(at-bananas on-chair)
               :del-list '(at-middle-room on-floor))
           (op 'push-chair-from-door-to-middle-room
               :preconds '(chair-at-door at-door)
               :add-list '(chair-at-middle-room at-middle-room)
               :del-list '(chair-at-door at-door))
           (op 'walk-from-door-to-middle-room
               :preconds '(at-door on-floor)
               :add-list '(at-middle-room)
               :del-list '(at-door))
           (op 'grasp-bananas
               :preconds '(at-bananas empty-handed)
               :add-list '(has-bananas)
               :del-list '(empty-handed))
           (op 'drop-ball
               :preconds '(has-ball)
               :add-list '(empty-handed)
               :del-list '(has-ball))
           (op 'eat-bananas
               :preconds '(has-bananas)
               :add-list '(empty-handed not-hungry)
               :del-list '(has-bananas hungry)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org1c6b0ba" class="outline-3">
<h3 id="org1c6b0ba">Maze Ops</h3>
<div class="outline-text-3" id="text-org1c6b0ba">
<p>
The maze is modeled as a grid. 
</p>
<pre class="example">
+-----------+--+
| 1  2  3  4| 5|
+---------  |  |
| 6| 7  8  9|10|
|     ---+  |  |
|11 12 13|14|15|
|   --+--+--+  |
|16 17|18|19 20|
+--            |
|21 22 23 24|25|
+-----------+--+
</pre>
<p>
The maze can also be seen as undirected graph and adding utility functions to model that abstraction saves typing. Code generation is the ultimate data compression.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org7c0fa5f">;;; THIS FILE AUTOGENERATED
;;; It has a dependency on #'mappend
&lt;&lt;make-maze-op&gt;&gt;

&lt;&lt;make-maze-ops&gt;&gt;

(defparameter *maze-ops*
  (mapcar #'convert-op
          (mappend
             #'make-maze-ops
             '((1 2) (2 3) (3 4) (4 9) (9 14) (9 8) (8 7) (7 12) (12 13)
              (12 11) (11 6) (11 16) (16 17) (17 22) (21 22) (22 23)
              (23 18) (23 24) (24 19) (19 20) (20 15) (15 10) (10 5) (20 25)))))

&lt;&lt;maze-find-path&gt;&gt;

&lt;&lt;maze-destination&gt;&gt;
</pre>
</div>
</div>
<div id="outline-container-orgac3f98b" class="outline-4">
<h4 id="orgac3f98b">make-maze-ops</h4>
<div class="outline-text-4" id="text-orgac3f98b">
<p>
This function is very simple, all the interestin work happens at <code>make-maze-op</code>.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgbc15754">(defun make-maze-ops (pair)
  "Make maze ops in both directions."
  (list (make-maze-op (first pair) (second pair))
        (make-maze-op (second pair) (first pair))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org60ef23b" class="outline-4">
<h4 id="org60ef23b">make-maze-op</h4>
<div class="outline-text-4" id="text-org60ef23b">
<p>
Here is an example of the power of macros. It parses a <code>pair</code> and expands it out to a <code>struct</code>. Compared to the typing saved by creating both operations from one, this saves many times more.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org76fb8f1">(defun make-maze-op (here there)
  "Make an operator to move between two places."
  (op `(move from ,here to ,there)
      :preconds `((at ,here))
      :add-list `((at ,there))
      :del-list `((at ,here))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org039191d" class="outline-4">
<h4 id="org039191d">Using Maze Ops in Another Program</h4>
<div class="outline-text-4" id="text-org039191d">
<p>
By returning the path through the maze (or GPS's solution steps in general) we have information that can be used by another program. In particular we may have useful data at the business logic layer of abstraction. This can be fed back into our knowledge base at a high level.
</p>
</div>
<ul class="org-ul"><li><a id="org85c31c0"></a>find-path<br /><div class="outline-text-5" id="text-org85c31c0">
<p>
Once again, Norvig uses 'macros' in the weak sense of backquoting and unquoting. It never really hit me that macros are all about building data-structures. Here the case is lists. Previously it was building the <code>defstruct</code>. While Lisp's homoiconicity allows data structures to be code, macros operate on data structure abstractions not code abstractions.
</p>

<div class="org-src-container">
<pre class="src src-lisp" id="org3f8c357">(defun find-path (start end)
  "Search a maze for a path from start to end."
  (let ((results (gps `((at ,start))
                      `((at ,end)))))
    (unless (null results)
      (cons start
            (mapcar #'destination
                    (remove '(start)
                            results
                            :test #'equal))))))
</pre>
</div>
</div></li>
<li><a id="orga3ad6c9"></a>destination<br /><div class="outline-text-5" id="text-orga3ad6c9">
<p>
I don't really like this function. It seems to be more than one level of abstraction down from mazes. Aesthetically, there should be something about x's and y's sitting in between mazes and lists. Oh well.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org1c18223">(defun destination (action)
  "Find the Y in '(executing (move from X to Y))"
  (fifth (second action)))
</pre>
</div>
</div></li></ul>
</div>
</div>
</div>
<div id="outline-container-org3bcabad" class="outline-2">
<h2 id="org3bcabad">TESTING CODE</h2>
<div class="outline-text-2" id="text-org3bcabad">
</div><div id="outline-container-org5c65e2e" class="outline-3">
<h3 id="org5c65e2e">GPSv1 School Ops</h3>
<div class="outline-text-3" id="text-org5c65e2e">
<p>
A complete package of source and parameters (essentially an application) for the first version of GPS with the School Ops&#x2026;gotta love literate programming.
</p>
<div class="org-src-container">
<pre class="src src-lisp">;;; THIS FILE AUTOGENERATED
;;;
;;; This file combines GPS version 1 with school ops to allow testing.
;;; Example use:
;;; (gps '(son-at-home car-needs-battery have-money have-phone-book) '(son-at-school) *school-ops*)
;;; (gps '(son-at-home have-money) '(son-at-school) *school-ops*)
;;; (gps '(son-at-school) '(son-at-school) *school-ops*)
;;;

&lt;&lt;school-ops&gt;&gt;

&lt;&lt;gps-v-one&gt;&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-org0b40c48" class="outline-3">
<h3 id="org0b40c48">GPSv2 Monkey Ops</h3>
<div class="outline-text-3" id="text-org0b40c48">
<div class="org-src-container">
<pre class="src src-lisp">;;; THIS FILE AUTOGENERATED
;;;
;;; This file combines GPS version 2 with banana ops to allow testing.
;;; Usage:
;;; (use *banana-ops*)
;;; Example:
;;; (gps '(at-door on-floor has-ball hungry chair-at-door) '(not-hungry))
&lt;&lt;banana-ops&gt;&gt;

&lt;&lt;gps&gt;&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgedf02b3" class="outline-3">
<h3 id="orgedf02b3">GPSv3 Maze Ops</h3>
<div class="outline-text-3" id="text-orgedf02b3">
<p>
For simplicity the higher level maze operations illustrating the use of GPS to generate data for the maze domain have been added to the general testing file. Another file to test those would just add noise to the repository&#x2026;since I have not got a handle on package management yet. That's going to wait for the next chapter of Norvig's book.
</p>
<div class="org-src-container">
<pre class="src src-lisp">;;; This file AUTOGENERATED

&lt;&lt;maze-ops&gt;&gt;

&lt;&lt;gps&gt;&gt;

&lt;&lt;maze-find-path&gt;&gt;

&lt;&lt;maze-destination&gt;&gt;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: benrudgers</p>
<p class="date">Created: 2017-02-19 Sun 15:35</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
